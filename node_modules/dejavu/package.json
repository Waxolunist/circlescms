{
  "name": "dejavu",
  "description": "A set of object-oriented tools for JavaScript",
  "keywords": [
    "oop",
    "interface",
    "class",
    "abstract",
    "final",
    "inheritance"
  ],
  "version": "0.4.0",
  "author": {
    "name": "IndigoUnited",
    "email": "hello@indigounited.com",
    "url": "http://indigounited.com"
  },
  "main": "dist/node/node.js",
  "dependencies": {
    "amdefine": "~0.0.4",
    "mout": "~0.4.0"
  },
  "devDependencies": {
    "almond": "~0.2.1",
    "mocha": "~1.8.1",
    "expect.js": "~0.2.0",
    "domReady": "git://github.com/requirejs/domReady.git",
    "requirejs": "~2.1.2",
    "rimraf": "~2.1.2",
    "glob": "~3.1.21",
    "async": "~0.2.6",
    "fstream": "~0.1.22",
    "mkdirp": "~0.3.5",
    "dejavu-optimizer": "~0.4.0",
    "testem": "~0.2.70"
  },
  "scripts": {
    "build": "node bin/build",
    "test": "mocha -R spec test/strict --node && mocha -R spec test/loose --node && mocha -R spec test/node_specific && testem ci",
    "postinstall": "node bin/post_install.js"
  },
  "bugs": {
    "url": "https://github.com/IndigoUnited/dejavu/issues/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/IndigoUnited/dejavu.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://www.opensource.org/licenses/mit-license.php"
    }
  ],
  "engine": "node >= 0.8.x",
  "readme": "dejavu\n------\n\n[![Build Status](https://secure.travis-ci.org/IndigoUnited/dejavu.png)](http://travis-ci.org/IndigoUnited/dejavu)\n\nHave you ever had the feeling that you're seeing something you've already seen\nbefore? That's the feeling you get when using `dejavu`.\n\nIf you are a developer coming from a language like PHP, Java, ActionScript 3.0,\nand others, it's likely that you are already familiar with Object Oriented\nProgramming. However, JavaScript uses prototypal inheritance which, although\npowerful and flexible, can be difficult to unde\nrstand, and specially to maintain\nin large projects.\n\n`dejavu` is a library that delivers classical inheritance on top of JavaScript\nprototypal inheritance, making it a breeze to move into JavaScript.\n\n\n\n## Why another?\n\nThere are some libraries out there able to shim classical inheritance,\nhowever none offers all the functionality that many programmers require.\n\nAlso, even though being one of the most feature rich OOP libraries out there, it has an outstanding performance, rivaling with vanilla in production.\n\n\n\n## Features\n\n* Classes (concrete, abstract and final)\n* Interfaces\n* Mixins (so you can get some sort of multiple inheritance)\n* Private and protected members\n* Static members\n* Constants\n* Context binding for functions\n* Method signature checks\n* Possible to extend or borrow from vanilla classes\n* Custom instanceOf with support for Interfaces\n* Two builds, `regular` and `AMD` based\n    * `AMD` optimized for speeding up developer workflow, allowing testing\n      without the need to re-compile everything into a single file\n    * `regular` if you are not using `AMD` in your projects\n* Two modes for each build, `strict` and `loose`\n    * `strict` best in development, enforcing a lot of checks, making sure you\n      don't make many typical mistakes\n    * `loose` best for production, without checks, improving performance\n\nUsers are encouraged to declare\n['use strict'](https://developer.mozilla.org/en/JavaScript/Strict_mode) while\nusing the `dejavu` in strict mode, otherwise some code might fail silently.\nThis can happen because `dejavu` uses `Object.freeze` and `Object.seal` to lock\nclasses and instances, guaranteeing that no one changes the behaviour of your\nclasses by replacing methods, etc, and possibly breaking your code, making it\nreally hard to pin point what's wrong. Although this is the default behaviour, it can be changed.\n\nYou will read more on it later in this document.\n\n**Do not confuse 'use strict' with the dejavu strict mode.**\n\n\n\n## Getting started\n\nThe quickest way to start using `dejavu` in your project, is by simply including\n`dist/regular/strict/dejavu.js` (note that this is in __strict__ mode).\n\nIf you're developing a __client-side__ app, simply put the file in some folder,\nand include it in the HTML:\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta http-equiv=\"Content-Type\"\n              content=\"text/html; charset=UTF-8\">\n        <script type=\"text/javascript\" src=\"dejavu.js\"></script>\n    </head>\n    <body>\n        <script type=\"text/javascript\">\n            'use strict';\n\n            // declare the \"Person\" class\n            var Person = dejavu.Class.declare({\n                _name: null,\n\n                initialize: function(name) {\n                    this.setName(name);\n                },\n\n                setName: function(name) {\n                    this._name = name;\n\n                    return this;\n                },\n\n                getName: function() {\n                    return this._name;\n                }\n            });\n\n            // create a new instance of person\n            var indigo = new Person('Marco');\n            console.log('A new indigo was born,', indigo.getName());\n        </script>\n    </body>\n</html>\n```\n\nThis will make a `dejavu` global available for you.\nIf you're developing in __Node.js__, install it with `npm install dejavu` and use it like so:\n\n```js\nvar dejavu = require('dejavu');\n\n// declare the \"Person\" class\nvar Person = dejavu.Class.declare({\n    _name: null,\n\n    initialize: function(name) {\n        this.setName(name);\n    },\n\n    setName: function(name) {\n        this._name = name;\n\n        return this;\n    },\n\n    getName: function() {\n        return this._name;\n    }\n});\n\n// create a new instance of person\nvar indigo = new Person(\"Marco\");\nconsole.log(\"A new indigo was born,\", indigo.getName());\n```\n\nThe installation will create a `.dejavurc` in your package, where you can enable/disable the strict mode as well as change other dejavu options.\nBy default the strict mode is used. Still, you want to leverage your package with the loose mode.\nBecause dejavu reads`.dejavurc` from the process.cwd(), packages that require your package will be running the loose mode unless they also define a `.dejavurc` (which will only happen if they also depend on dejavu directly).\n\n\n\n## Performance\n\nSince all those nice features and common rules of classic OOP degrade\nperformance, `dejavu` has two separates modes, for different stages in the\ndevelopment.\n\nThe `strict` mode is suitable for __development__, and will do all sorts of\nchecks, throwing an error when you try to do something considered illegal.\n\n**Note that if your project works in strict mode, it will work in loose mode.**\n\nAs for the `loose` mode, there is no overhead associated with checks, thus\nmaking it suitable for __production__, since it will be more efficient and\nhave a __lower memory footprint and filesize__.\n\nFinally, in order to achieve that extra edge, that puts `dejavu` next to vanilla\nJS in terms of performance, you should run the optimizer that is bundled with\nthe library. Note that this step is completely optional, and `dejavu` will still\nperform faster than most libraries, even if you don't run the [optimizer](https://github.com/IndigoUnited/dejavu-optimizer).\nThe optimizer will analyse your code and make some improvements,\nboosting it a bit further.\n\nYou can check the benchmarks in [jsperf](http://jsperf.com/oop-benchmark/107)\ncomparing `dejavu` with other OOP libraries. Note that the loose mode\nis used in this test, simulating a production environment, and both the normal\nand optimized versions are tested. It is also important to mention that many libraries like\n[JSFace](https://github.com/tnhu/jsface) does not chain prototypes. This gives\nJSFace an extra edge in performance in some browsers, like Firefox, but renders\nthe `instanceof` operator useless.\n\n\n\n## Syntax\n\n### Overview\n\nHere's an overview of what most developers look for in an OOP library. You can find complete examples further down.\n\n```js\nvar Person = Class.declare({\n    // although not mandatory, it's really useful to identify\n    // the class name, which simplifies debugging\n    $name: 'Person',\n\n    // this is a protected property, which is identified by\n    // the single underscore. two underscores denotes a\n    // private property, and no underscore stands for public\n    _name: null,\n    __pinCode: null,\n\n    // class constructor\n    initialize: function (name, pinCode) {\n        this._name = name;\n        this.__pinCode = pinCode;\n\n        // note that we're binding to the current instance with `$bind`.\n        // this will be explained with great detail later on\n        setTimeout(this._logName.$bind(this), 1000);\n    },\n\n    // public method (follows the same visibility logic, in this case with no underscore)\n    getName: function () {\n        return this._name;\n    }\n\n    _logName: function () {\n        console.log(this._name);\n    }\n});\n```\n\n### Complete example\n\nFor those looking for something more, here's a more complete usage of `dejavu`.\n\nThis example illustrates the usage of:\n\n- `$name` meta attribute\n- `this.$self` vs `this.$static`\n- `$super()` for accessing overridden methods\n- `instanceOf`\n- member visibility\n- statics, abstracts, abstract statics, finals, final statics and constants\n- `$extends` vs `$borrows`\n\nIn this case, and keep in mind that this is just for illustration purposes, we'll create three interfaces, that are implemented by an abstract class, that is then extended by a concrete class.\n\n\n```js\nvar dejavu = require('dejavu');\n\n// ------------ AN INTERFACE ------------\n// this interface is useless, is only here to illustrate\n// that interfaces can extend other interfaces\nvar UselessInterface = dejavu.Interface.declare({\n    $name: 'UselessInterface'\n});\n\nvar PersonInterface = dejavu.Interface.declare({\n    $name: 'PersonInterface',\n    // if you need to extend multiple interfaces,\n    // just provide an array\n    $extends: UselessInterface,\n\n    // interface methods can specify argument list, and any class\n    // that implements that interface will be automatically checked,\n    // to make sure it obeys the method signature. If you want to\n    // specify an optional argument, you should prepend it by a dollar\n    // sign, like so: someMethod(arg1, arg2, $thisArgIsOptional)\n    getName: function () {},\n    setName: function (name) {}\n});\n\n// ------------ ANOTHER INTERFACE ------------\nvar EngineerInterface = dejavu.Interface.declare({\n    $name: 'EngineerInterface',\n\n    think: function(subject) {}\n});\n\n// ------------ AN ABSTRACT CLASS ------------\nvar AbstractIndigo = dejavu.AbstractClass.declare({\n    $name: 'AbstractIndigo',\n    // implements multiple interfaces\n    $implements: [PersonInterface, EngineerInterface],\n\n    $constants: {\n        INDIGO_WEBSITE: 'http://www.indigounited.com/',\n        INDIGO_EMAIL:   'hello@indigounited.com'\n    },\n\n    $statics: {\n        logIndigoInfo: function () {\n            // by using this.$static, we're making sure that dejavu\n            // uses late binding to resolve the member. If you're\n            // looking for early binding, you can use this.$self\n            // instead\n            console.log(\n                this.$static.INDIGO_WEBSITE,\n                this.$static.INDIGO_EMAIL\n            );\n        }\n    },\n\n    // method/attribute visibility is controlled by\n    // the number of underscores that the identifier\n    // has:\n    // public:    no underscores\n    // protected: 1 underscore\n    // private:   2 underscores\n    //\n    // the attribute below is protected\n    _name: null,\n\n    getName: function () {\n        return this._name;\n    },\n\n    setName: function (name) {\n        this._name = name;\n\n        return this;\n    },\n\n    // note that we're not implementing the method `think()` of the\n    // EngineerInterface. This will be automatically turned into an\n    // abstract method, since we're in an abstract class\n    $abstracts: {\n        beAwesome: function () {}\n\n        // you can also put \"$statics {}\" here\n        // to create an abstract static method\n    },\n\n    // finals are not overridable\n    $finals: {\n        // you can also put \"$statics {}\" here\n        // to create a final static method\n\n        thisIsFinal: function () {\n            console.log('Can\\'t change this!');\n        }\n    }\n});\n\n// ------------ A CONCRETE CLASS ------------\n// also, if you need this concrete class to be final,\n// you can just use dejavu.FinalClass.declare instead\nvar Indigo = dejavu.Class.declare({\n    $name: 'Indigo',\n    // class extends another one.\n    //\n    // in case you need to extend from several classes,\n    // you can instead use $borrows, and specify an\n    // array of identifiers. Still, note that borrowing\n    // will not allow you to perform dejavu.instanceOf\n    // tests, as the class is not technically extending\n    // the other, just borrowing its behaviour.\n    $extends: AbstractIndigo,\n\n    _subject: 'nothing',\n\n    initialize: function (name) {\n        // call the parent method, in this case the parent constructor,\n        // but can be applied to any method when you need to call the\n        // overridden method\n        this.$super();\n\n        this.setName(name);\n\n        this._logThought();\n    },\n\n    beAwesome: function () {\n        console.log(this._name, 'is being awesome!');\n        this.$self.logIndigoInfo();\n        this.think('the next big thing');\n    },\n\n    think: function (subject) {\n        this._subject = subject;\n    },\n\n    _logThought: function () {\n        console.log(this._name, 'is thinking about', this._subject);\n    }\n});\n\nvar indigo = new Indigo('Andr√©');\nindigo.beAwesome();\n\n// check the type of an object\nconsole.log(\n    dejavu.instanceOf(indigo, EngineerInterface) ?\n    'we have an engineer!'\n    : 'say what now?'\n);\nconsole.log(dejavu.instanceOf(indigo, Indigo) ?\n    'we have an indigo!'\n    : 'say what now?'\n);\n// native instanceof also works for classes, but not for interfaces\nconsole.log((indigo instanceof Indigo) ?\n    'we have an indigo!'\n    : 'say what now?'\n);\n\n```\n\n\n\n## Taking it to another level\n\nFront-end devs are encouraged to program using the AMD paradigm because of its obvious benefits.\nSince dejavu is built on it, it will integrate seamlessly with your AMD loader.\n\n```js\n{\n    // your loader config\n    paths: {\n           'mout': '../vendor/mout/src'\n    },\n    packages: [\n        {\n            name: 'dejavu',\n            // You can switch to the loose mode anytime\n            location: '/path/to/dejavu/dist/strict'\n        }\n    ]\n}\n```\n\nWith this setup, you can require the dejavu object or specific parts of it:\n\n```js\n// Load dejavu completely\ndefine(['dejavu'], function (dejavu) {\n\n    // the dejavu variable is an object that contains:\n    // Class\n    // FinalClass\n    // AbstractClass\n    // Interface\n    // instanceOf\n    // options\n\n    // example usage\n    var Person = dejavu.Class.declare({\n        initialize: function () {\n            // ...\n        }\n    });\n\n    return Person;\n});\n\n// In this case, only the `Class` module of `dejavu` is included,\n// which means all the other modules are not loaded.\ndefine(['dejavu/Class'], function (Class) {\n\n    // Example usage\n    var Person = Class.declare({\n        initialize: function () {\n            // ...\n        }\n    });\n\n    return MyClass;\n});\n```\n\n\n\n## Additional details\n\n### Binding and anonymous members\n\nYou will eventually run into a situation where you want to declare a callback that accesses class members. On traditional JavaScript, you would just `var that = this` or `.bind(this)`, and everything would be ok, because there is no restriction on visibility. Since `dejavu` enforces this, you will need to mark that callback as a member of the class, using something like the following:\n\n```js\n// ...\nvar that = this;\nsetTimeout(function () {\n    that._someProperty = 'protected properties on callbacks';\n}.$member(), 1000);\n```\n\n```js\n// ...\nsetTimeout(function () {\n    this._someProperty = 'protected properties on callbacks';\n}.$member().bind(this), 1000);\n```\n\nIf the `$member().bind(this)` is too verbose for you, you can just `.$bind(this)`, which is equivalent.\n\nFinally, when defining a method directly on the class declaration that you know will always be used using the class context, you can bind it right there like so:\n\n```js\nvar MyClass = dejavu.Class.declare({\n    $name: 'MyClass',\n\n    doSomething: function () {\n        // notice that _someMethod is $bound() below,\n        // which is more efficient than $bind()ing on\n        // every execution of doSomething()\n        setTimeout(this._someMethod, 1000);\n    },\n\n    _someMethod: function () {\n        console.log('method efficiently bound');\n    }.$bound()\n});\n```\n\n### Classes/instances are locked\n\nBy default, constructors and instances are locked. This means that no one can monkey patch your code.\n\nThis behaviour can be changed in two ways:\n\n#### With the $locked flag:\n\n```js\nvar UnlockedIndigo = Class.declare({\n    $name: 'UnlockedIndigo',\n    $locked: false\n\n    initialize: function () {\n        // Altough the foo property is not declared,\n        // it will not throw an error\n\n        this.name = 'Filipe';\n    },\n\n    talk: function () {\n        console.log('An indigo is talking!');\n    }\n});\n```\n\nMembers can be added, replaced and deleted from the prototype:\n\n```js\nUnlockedIndigo.prototype.age = 20;\nUnlockedIndigo.prototype.talk = function () {\n    console.log('... now is running');\n};\n```\n\nMembers can be added, replaced and deleted from the instance:\n\n```js\nvar filipe     = new UnlockedIndigo();\nfilipe.friends = ['Marco','Andre'];\nfilipe.talk    = function () {\n    console.log('I am talking about dejavu!');\n};\n```\n\n#### By setting the global option:\n\nThis will change the default behaviour, but classes can still override it with the $locked flag.\n\n```js\ndejavu.options.locked = false;\n```\n\nNote that once a class is unlocked, its subclasses cannot be locked.\nAlso, although undeclared members are allowed, they will not have their access controlled (they are interpreted as public).\n\n\n\n### Vanilla classes\n\n`dejavu` allows you to extend or borrow vanilla classes. In this case, constructors and instances are forcibly UNLOCKED.\n\n```js\nfunction Person(name) {\n    this.name = name;\n};\n\nvar Engineer = dejavu.Class.declare({\n    $extends: Person\n});\n\nvar filipe = new Engineer('Filipe');\n// Engineer class and filipe instance are unlocked\n\n```\n\n\n### Debugging\n\nIn strict mode, logging instances with `console.log` will print some strange stuff (getters, setters, etc).\nThis happens because `dejavu` manages accesses to private/protected members as well as make other stuff work.\nTo get around this issue, `dejavu` provides a `console.inspect` method that works just like `console.log` but prints a friendly object representation of the instance.\n\n\n\n## Works on\n\n* IE (6+)\n* Chrome (4+)\n* Safari (3+)\n* Firefox (3.6+)\n* Opera (9+)\n* Node.js and Rhino\n\n\n\n## Dependencies\n\ndejavu depends on [mout](https://github.com/mout/mout).\nIf you use the regular build, you don't need to worry because all functions used from mout are bundled for you.\nIf you use the AMD build, learn [how](https://github.com/IndigoUnited/dejavu#taking-it-to-another-level) to setup your loader.\nIf you use dejavu on `node`, `npm` will take care of fetching everything for you.\n\n\n## Building dejavu\n\nSimply run `npm install` to install all the tools needed.\nThen just run `npm run-script build`.\n\n\n\n## Testing dejavu\n\n`dejavu` has more than 250 tests.\nSimply run `npm install` to install all the tools needed.\nThen just run `npm test` to execute them.\n\n\n\n## License ##\n\nReleased under the [MIT License](http://www.opensource.org/licenses/mit-license.php).\n",
  "readmeFilename": "README.md",
  "_id": "dejavu@0.4.0",
  "dist": {
    "shasum": "d888dbe0ea8ca039bbcd554893d656800addd550"
  },
  "_from": "dejavu@",
  "_resolved": "http://registry.npmjs.org/dejavu/-/dejavu-0.4.0.tgz"
}
